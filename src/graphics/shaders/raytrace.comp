#version 450

#extension GL_EXT_shader_explicit_arithmetic_types_int8: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_scalar_block_layout: require
#extension GL_GOOGLE_include_directive: require

precision highp float;

#include "math.glslh"



/* ===== Shader Input ===== */
layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, set = 0, rgba8) uniform writeonly image2D colorImage;

layout (binding = 0, set = 1, rgba8) uniform image2D oldColorImage;

layout (binding = 0, set = 2, rgba8) uniform image2D normalImage;

layout (binding = 0, set = 3, rgba8) uniform image2D positionImage;

layout (scalar, binding = 0, set = 4) buffer stateBuffer
{
    uint8_t state[];
};

layout (binding = 0, set = 5) uniform SceneInfoUBO {
    ivec2 screen_dimensions;
    ivec3 world_dimensions;

    vec3 camera_position;
    vec3 camera_direction;
    vec3 old_camera_position;
    vec3 old_camera_direction;

    int chunk_size;
    int local_size;

    int spectator_mode;
} scene_info;

layout (scalar, binding = 0, set = 6) buffer subchunkStateBuffer
{
    uint8_t subchunk_state[];
};

layout (push_constant) uniform Push {
    int frame_num;
    int max_ray_steps;
    int max_bounces;
    int rays_per_pixel;
    int use_blue_noise;
    int use_temp_accumulation;
    int invalidate_accumulation;
} push;



/* ===== Voxel Rendering Data ===== */
#define VOXTYPE_SOLID   0x0u
#define VOXTYPE_LIQUID  0x1u
#define VOXTYPE_GAS     0x2u

#define VOX_AIR         0x0u
#define VOX_SAND        0x1u
#define VOX_DIRT        0x2u
#define VOX_WATER       0x3u
#define VOX_SUN         0x4u
#define VOX_FOG         0x5u

struct VoxelMaterial {
    uint voxtype;
    vec3 color;
    vec3 emmision_color;
    float emmision_strength;
    float extinction_coefficient;
};

const VoxelMaterial voxeldata[6] = VoxelMaterial[](
    VoxelMaterial(VOXTYPE_GAS, vec3(0.0f), vec3(0.0f), 0.0f, 0.0f),                             // Air
    VoxelMaterial(VOXTYPE_SOLID, vec3(0.761f, 0.698f, 0.502f), vec3(0.0f), 0.0f, 10.0f),        // Sand
    VoxelMaterial(VOXTYPE_SOLID, vec3(0.608f, 0.463f, 0.326f), vec3(0.0f), 0.0f, 10.0f),        // Dirt
    VoxelMaterial(VOXTYPE_LIQUID, vec3(0.831f, 0.945f, 0.977f), vec3(0.0f), 0.0f, 10.0f),       // Water
    VoxelMaterial(VOXTYPE_SOLID, vec3(0.0f), vec3(0.988f, 0.898f, 0.439f), 1.0f, 10.0f),        // Sun
    VoxelMaterial(VOXTYPE_GAS, vec3(0.684f, 0.684f, 0.684f), vec3(0.0f), 0.0f, 0.25f)           // Fog
);



/* ===== Helper Functions ===== */
VoxelMaterial getVoxel(ivec3 loc) {
	int index = loc.z * scene_info.world_dimensions.y * scene_info.world_dimensions.x + loc.y * scene_info.world_dimensions.x + loc.x;
    if (loc.x >= 0 && loc.x < scene_info.world_dimensions.x &&
        loc.y >= 0 && loc.y < scene_info.world_dimensions.y &&
        loc.z >= 0 && loc.z < scene_info.world_dimensions.z) {
        int voxel = int(state[index]);
	    return voxeldata[voxel];
    } else {
        return voxeldata[VOX_AIR];
    }
}

bool getSubchunk(ivec3 pos) {
    ivec3 num_subchunks = scene_info.world_dimensions / 8;
    if (pos.x >= 0 && pos.x < num_subchunks.x &&
        pos.y >= 0 && pos.y < num_subchunks.y &&
        pos.z >= 0 && pos.z < num_subchunks.z) {
        int index = pos.z * num_subchunks.y * num_subchunks.x + pos.y * num_subchunks.x + pos.x;
        return !bool(subchunk_state[index]);
    } else {
        return false;
    }
}



/* ===== Raytracing Implementation ===== */
struct ray {
    vec3 position;
    vec3 direction;
};

struct traceRayInfo {
    vec3 incoming_light;
    vec3 ray_color;
    vec3 initial_hit_pos;
    vec3 initial_hit_normal;
    vec3 initial_incoming_light;
    vec3 initial_ray_color;
    bool hit_voxel;
};

traceRayInfo traceRay(vec3 ray_pos, vec3 ray_dir, int ray_index, vec3 incoming_light_init, vec3 ray_color_init, bool is_init_ray, bool is_sun_ray) {
    vec3 incoming_light = incoming_light_init;
    vec3 ray_color = ray_color_init;

    bool first_bounce = true;

    traceRayInfo ray_info;
    ray_info.initial_hit_pos = ray_pos;
    ray_info.initial_hit_normal = ray_dir;
    ray_info.initial_incoming_light = incoming_light_init;
    ray_info.initial_ray_color = ray_color_init;

    int max_ray_bounces = push.max_bounces;
    if (is_sun_ray || is_init_ray) {
        max_ray_bounces = 1;
    }
    for (int raybounce = 0; raybounce < max_ray_bounces; raybounce++) {
        uint total_ray_index = ray_index * push.max_bounces + raybounce;

        uint rand_seed = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * scene_info.screen_dimensions.x;

        ivec3 voxel_step = ivec3(sign(ray_dir));
        ivec3 subchunk_step = voxel_step * 8;

        ivec3 voxel_pos = ivec3(floor(ray_pos));
        ivec3 subchunk_pos = ivec3(floor(ray_pos / 8.0f));

        vec3 voxel_t_delta_dist = abs(vec3(1.0f) / ray_dir);
        vec3 t_delta_dist = voxel_t_delta_dist * 8.0f;

        vec3 voxel_t_bound_dist = voxel_t_delta_dist * ((sign(ray_dir) * 0.5f + 0.5f) - sign(ray_dir) * fract(vec3(ray_pos)));
        vec3 t_bound_dist = t_delta_dist * ((sign(ray_dir) * 0.5f + 0.5f) - sign(ray_dir) * fract(vec3(ray_pos) / 8.0f));

        bool hit = false;
        float final_t = 0.0f;

        VoxelMaterial voxel = voxeldata[VOX_AIR];
        vec3 normal_pos = ray_pos;
        vec3 normal_dir = ray_dir;
        
        int step = 0;
        while (step < push.max_ray_steps) {
            /*
            if (length(vec3(subchunk_pos * 8.0f) - scene_info.camera_position) > 50.0f) {
                voxel = voxeldata[VOX_FOG];
                float rand = randomValue(rand_seed);
                if (rand < voxel.extinction_coefficient) {
                    hit = true;
                }
            }
            */

            if (getSubchunk(subchunk_pos)) {
                vec3 exit_subchunk_pos = ray_pos + (final_t + 0.001f) * ray_dir;

                voxel_pos = ivec3(floor(exit_subchunk_pos));
                ivec3 old_voxel_pos = ivec3(0);
                
                voxel_t_bound_dist = voxel_t_delta_dist * ((sign(ray_dir) * 0.5f + 0.5f) - sign(ray_dir) * fract(vec3(exit_subchunk_pos)));

                ivec3 subchunk_min = subchunk_pos * 8;
                ivec3 subchunk_max = subchunk_min + ivec3(7);

                while (!all(equal(old_voxel_pos, voxel_pos)) && all(greaterThanEqual(voxel_pos, subchunk_min)) && all(lessThanEqual(voxel_pos, subchunk_max))) {
                    voxel = getVoxel(voxel_pos);
                    if (voxel.voxtype != VOXTYPE_GAS) {
                        hit = true;
                        break;
                    }

                    old_voxel_pos = voxel_pos;
                    if (voxel_t_bound_dist.x < voxel_t_bound_dist.y) {
                        if (voxel_t_bound_dist.x < voxel_t_bound_dist.z) {
                            float face = float(voxel_pos.x) + ((0.5f * voxel_step.x) + 0.5f);
                            final_t = (face - ray_pos.x) / ray_dir.x;
                            voxel_t_bound_dist.x += voxel_t_delta_dist.x;
                            voxel_pos.x += voxel_step.x;
                            normal_dir = vec3(-float(voxel_step.x), 0.0f, 0.0f);
                        }
                        else {
                            float face = float(voxel_pos.z) + ((0.5f * voxel_step.z) + 0.5f);
                            final_t = (face - ray_pos.z) / ray_dir.z;
                            voxel_t_bound_dist.z += voxel_t_delta_dist.z;
                            voxel_pos.z += voxel_step.z;
                            normal_dir = vec3(0.0f, 0.0f, -float(voxel_step.z));
                        }
                    }
                    else {
                        if (voxel_t_bound_dist.y < voxel_t_bound_dist.z) {
                            float face = float(voxel_pos.y) + ((0.5f * voxel_step.y) + 0.5f);
                            final_t = (face - ray_pos.y) / ray_dir.y;
                            voxel_t_bound_dist.y += voxel_t_delta_dist.y;
                            voxel_pos.y += voxel_step.y;
                            normal_dir = vec3(0.0f, -float(voxel_step.y), 0.0f);
                        }
                        else {
                            float face = float(voxel_pos.z) + ((0.5f * voxel_step.z) + 0.5f);
                            final_t = (face - ray_pos.z) / ray_dir.z;
                            voxel_t_bound_dist.z += voxel_t_delta_dist.z;
                            voxel_pos.z += voxel_step.z;
                            normal_dir = vec3(0.0f, 0.0f, -float(voxel_step.z));
                        }
                    }
                }

                if (hit) {
                    break;
                }
            }

            if (t_bound_dist.x < t_bound_dist.y) {
                if (t_bound_dist.x < t_bound_dist.z) {
                    float face = (float(subchunk_pos.x) + ((0.5f * voxel_step.x) + 0.5f)) * 8.0f;
                    final_t = (face - ray_pos.x) / ray_dir.x;
                    t_bound_dist.x += t_delta_dist.x;
                    subchunk_pos.x += voxel_step.x;
                    normal_dir = vec3(-float(voxel_step.x), 0.0f, 0.0f);
                }
                else {
                    float face = (float(subchunk_pos.z) + ((0.5f * voxel_step.z) + 0.5f)) * 8.0f;
                    final_t = (face - ray_pos.z) / ray_dir.z;
                    t_bound_dist.z += t_delta_dist.z;
                    subchunk_pos.z += voxel_step.z;
                    normal_dir = vec3(0.0f, 0.0f, -float(voxel_step.z));
                }
            }
            else {
                if (t_bound_dist.y < t_bound_dist.z) {
                    float face = (float(subchunk_pos.y) + ((0.5f * voxel_step.y) + 0.5f)) * 8.0f;
                    final_t = (face - ray_pos.y) / ray_dir.y;
                    t_bound_dist.y += t_delta_dist.y;
                    subchunk_pos.y += voxel_step.y;
                    normal_dir = vec3(0.0f, -float(voxel_step.y), 0.0f);
                }
                else {
                    float face = (float(subchunk_pos.z) + ((0.5f * voxel_step.z) + 0.5f)) * 8.0f;
                    final_t = (face - ray_pos.z) / ray_dir.z;
                    t_bound_dist.z += t_delta_dist.z;
                    subchunk_pos.z += voxel_step.z;
                    normal_dir = vec3(0.0f, 0.0f, -float(voxel_step.z));
                }
            }
            step += 8;
        }

        if (step >= push.max_ray_steps && is_sun_ray) {
            voxel = voxeldata[VOX_SUN];
            hit = true;
        }

        if (hit) {
            normal_pos = ray_pos + (final_t - 0.002f) * ray_dir;
            float sun_dist = length(scene_info.world_dimensions - ray_pos);

            // Send a new ray at an angle to the surface that was hit
            ray_pos = normal_pos;
            vec2 frame_offset = scene_info.screen_dimensions * (push.frame_num % 8);
            ray_dir = randomHemisphereDirectionBlueNoise(
                gl_GlobalInvocationID.xy + frame_offset,
                gl_GlobalInvocationID.xy + 8 * scene_info.screen_dimensions + frame_offset,
                normal_dir, 
                total_ray_index, 
                2 + push.max_bounces * push.rays_per_pixel
            );

            // Mix the color of the hit object into the ray color
            vec3 emmited_light = voxel.emmision_color * voxel.emmision_strength;
            if (is_sun_ray) {
                float attenuation = 10000.0f / (sun_dist * sun_dist);
                incoming_light += emmited_light * ray_color * attenuation;
            } else {
                incoming_light += emmited_light * ray_color;
            }
            ray_color *= voxel.color;
            
            if (first_bounce) {
                imageStore(normalImage, ivec2(gl_GlobalInvocationID.xy), vec4(normal_dir * 0.5f + 0.5f, 1.0f));
                imageStore(positionImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(voxel_pos) / scene_info.world_dimensions, 1.0f));
                ray_info.initial_hit_pos = normal_pos;
                ray_info.initial_hit_normal = normal_dir;
                ray_info.initial_incoming_light = incoming_light;
                ray_info.initial_ray_color = ray_color;
                first_bounce = false;
            }
        } else {
            VoxelMaterial ambient = VoxelMaterial(VOXTYPE_SOLID, vec3(0.0f), vec3(1.0f), 0.2f, 0.0f);
            incoming_light += ambient.emmision_color * ambient.emmision_strength * ray_color;
            break;
        }
    }

    ray_info.incoming_light = incoming_light;
    ray_info.ray_color = ray_color;
    ray_info.hit_voxel = !first_bounce;
    
    return ray_info;
}

vec3 pixelToRay(vec2 screen_coords, vec2 screen_dimensions, float fov, vec3 camera_direction) {
    float aspect_ratio = screen_dimensions.x / screen_dimensions.y;

    // Convert to NDC
    vec2 ndc = (screen_coords / screen_dimensions) * 2.0f - 1.0f;

    float fov_scaling = tan(fov / 2.0f);

    // Ray in camera space
    vec3 ray_camera_space = vec3(ndc.x * aspect_ratio * fov_scaling, ndc.y * fov_scaling, 1.0f);

    // Ray in world space
    vec3 camera_plane_u = normalize(cross(camera_direction, vec3(0.0, 1.0, 0.0)));
    vec3 camera_plane_v = normalize(cross(camera_direction, camera_plane_u));
    vec3 ray_world_space = ray_camera_space.x * camera_plane_u + ray_camera_space.y * camera_plane_v + ray_camera_space.z * camera_direction;
    return normalize(ray_world_space);
}

vec2 rayToPixel(vec3 ray_direction, vec2 screen_dimensions, float fov, vec3 old_camera_direction) {
    float aspect_ratio = screen_dimensions.x / screen_dimensions.y;

    vec3 camera_plane_u = normalize(cross(old_camera_direction, vec3(0.0, 1.0, 0.0)));
    vec3 camera_plane_v = normalize(cross(old_camera_direction, camera_plane_u));
    vec3 ray_camera_space = vec3(dot(ray_direction, camera_plane_u), dot(ray_direction, camera_plane_v), dot(ray_direction, old_camera_direction));

    float fov_scaling = tan(fov / 2.0f);

    vec2 ndc = vec2(ray_camera_space.x / (aspect_ratio * fov_scaling * ray_camera_space.z), ray_camera_space.y / (fov_scaling * ray_camera_space.z));

    vec2 screen_coords = ((ndc + 1.0f) / 2.0f) * screen_dimensions;

    return screen_coords;
}

void main() {
    vec3 ray_pos = scene_info.camera_position;
    vec3 ray_dir = pixelToRay(gl_GlobalInvocationID.xy, scene_info.screen_dimensions, 3.141592f / 2.0f, scene_info.camera_direction);

    traceRayInfo init_ray_info = traceRay(ray_pos, ray_dir, 0, vec3(0.0f), vec3(1.0f), true, false);
    traceRayInfo curr_ray_info;
    vec3 sun_incoming_light = init_ray_info.incoming_light;
    vec3 env_incoming_light = vec3(0.0f);

    vec2 frame_offset = scene_info.screen_dimensions * (push.frame_num % 8);

    if (init_ray_info.hit_voxel) {
        traceRayInfo sun_ray_info = traceRay(
            init_ray_info.initial_hit_pos,
            normalize(scene_info.world_dimensions - init_ray_info.initial_hit_pos),
            1,
            init_ray_info.initial_incoming_light,
            init_ray_info.initial_ray_color,
            false,
            true
        );
        sun_incoming_light += sun_ray_info.incoming_light;

        for (int ray_index = 0; ray_index < push.rays_per_pixel; ray_index++) {
            uint total_ray_index = 2 + ray_index * push.max_bounces;
            ray_pos = init_ray_info.initial_hit_pos;
            ray_dir = randomHemisphereDirectionBlueNoise(
                gl_GlobalInvocationID.xy + frame_offset,
                gl_GlobalInvocationID.xy + 8 * scene_info.screen_dimensions + frame_offset,
                ray_dir, 
                total_ray_index, 
                2 + push.max_bounces * push.rays_per_pixel
            );

            curr_ray_info = traceRay(
                ray_pos,
                ray_dir,
                ray_index,
                init_ray_info.initial_incoming_light,
                init_ray_info.initial_ray_color,
                false,
                false
            );
            env_incoming_light += curr_ray_info.incoming_light;
        }
    }
    vec3 new_pixel_color = sun_incoming_light + (env_incoming_light / ((push.rays_per_pixel == 0) ? 1 : push.rays_per_pixel));

    // Apply temporal accumulation
    vec2 old_screen_coords = rayToPixel(normalize(init_ray_info.initial_hit_pos - scene_info.old_camera_position), scene_info.screen_dimensions, 3.141592f / 2.0f, scene_info.old_camera_direction);
    vec3 old_pixel_color = vec3(imageLoad(oldColorImage, ivec2(old_screen_coords)));

    vec3 final_color;
    if (push.use_temp_accumulation != 0 && init_ray_info.hit_voxel && push.invalidate_accumulation == 0 && old_screen_coords.x < scene_info.screen_dimensions.x && old_screen_coords.x >= 0 && old_screen_coords.y < scene_info.screen_dimensions.y && old_screen_coords.y >= 0) {
        final_color = old_pixel_color * 0.65f + new_pixel_color * 0.35f;
    } else {
        final_color = new_pixel_color;
    }
    
    // Write the final color to the image
    imageStore(colorImage, ivec2(gl_GlobalInvocationID.xy), vec4(final_color, 1.0f));
}